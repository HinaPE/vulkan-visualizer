#version 460
layout(local_size_x=16, local_size_y=16, local_size_z=1) in;
// density volume (R32F) -> 2D color (RGBA8)
layout(binding=0, r32f)  uniform image3D density;
layout(binding=1, rgba8) uniform image2D outColor;

// vw, vh, W, H, D, steps
layout(push_constant) uniform PC { float vw; float vh; float W; float H; float D; float steps; } pc;

float den(ivec3 p){ ivec3 s = imageSize(density); ivec3 q = clamp(p, ivec3(0), s-1); return imageLoad(density, q).x; }

void main(){ ivec2 gid = ivec2(gl_GlobalInvocationID.xy); ivec2 sz = imageSize(outColor); if (any(greaterThanEqual(gid, sz)) || any(lessThan(gid, ivec2(0)))) return;
    // Map screen pixel to volume X,Y
    vec2 uv = (vec2(gid) + 0.5) / vec2(sz);
    vec3 pos = vec3(uv.x * pc.W, uv.y * pc.H, 0.0);
    // Raymarch forward in +Z
    int N = int(max(1.0, pc.steps));
    float stepZ = max(pc.D / float(N), 1.0);
    vec3 accum = vec3(0.0);
    float alpha = 0.0;
    float sigma = 0.06; // absorption/scatter coefficient
    for (int i=0;i<N && alpha<0.995;i++){
        float d = den(ivec3(pos));
        // Simple alpha from density
        float a = 1.0 - exp(-d * sigma);
        vec3 col = vec3(d);
        // front-to-back compositing
        col = col * (1.0 - alpha) * a;
        accum += col;
        alpha += (1.0 - alpha) * a;
        pos.z += stepZ;
        if (pos.z >= pc.D) break;
    }
    // tone-map and tint
    vec3 color = accum / (1.0 + accum);
    color *= vec3(0.9, 0.95, 1.0);
    imageStore(outColor, gid, vec4(color, 1.0));
}

