#version 460
layout(local_size_x=8, local_size_y=8, local_size_z=8) in;
// src -> dst, velocity as RGB of RGBA32F (w unused)
layout(binding=0, rgba32f) uniform image3D srcField;
layout(binding=1, rgba32f) uniform image3D dstField;

layout(push_constant) uniform PC { float dt; float W; float H; float D; float diss; float _p1; float _p2; float _p3; } pc;

vec3 fetchV(ivec3 p){ ivec3 s = imageSize(srcField); ivec3 q = clamp(p, ivec3(0), s - 1); return imageLoad(srcField, q).xyz; }

vec3 trilerpV(vec3 pos){ // pos in voxel space
    vec3 p0 = floor(pos); vec3 f = clamp(pos - p0, vec3(0), vec3(1)); ivec3 i0 = ivec3(p0);
    vec3 c000 = fetchV(i0);
    vec3 c100 = fetchV(i0 + ivec3(1,0,0));
    vec3 c010 = fetchV(i0 + ivec3(0,1,0));
    vec3 c110 = fetchV(i0 + ivec3(1,1,0));
    vec3 c001 = fetchV(i0 + ivec3(0,0,1));
    vec3 c101 = fetchV(i0 + ivec3(1,0,1));
    vec3 c011 = fetchV(i0 + ivec3(0,1,1));
    vec3 c111 = fetchV(i0 + ivec3(1,1,1));
    vec3 c00 = mix(c000, c100, f.x);
    vec3 c10 = mix(c010, c110, f.x);
    vec3 c01 = mix(c001, c101, f.x);
    vec3 c11 = mix(c011, c111, f.x);
    vec3 c0 = mix(c00, c10, f.y);
    vec3 c1 = mix(c01, c11, f.y);
    return mix(c0, c1, f.z);
}

void main(){ ivec3 gid = ivec3(gl_GlobalInvocationID.xyz); if (gid.x>=int(pc.W) || gid.y>=int(pc.H) || gid.z>=int(pc.D)) return;
    vec3 v = fetchV(gid);
    vec3 pos = vec3(gid) - pc.dt * v; // backtrace in voxel space
    vec3 adv = trilerpV(pos) * pc.diss;
    imageStore(dstField, gid, vec4(adv, 0.0));
}

